<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF="8">
  <title>üõ†Ô∏è Admin Panel</title>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background-color: #e0f0ff;
      color: #000;
      padding: 20px;
    }
    .box {
      background-color: #f0f0f0;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    }
    label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
    }
    input:not([type="checkbox"]), button, textarea, select {
      padding: 8px 10px; /* Adjusted padding */
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 10px; /* Added margin bottom */
    }
    textarea {
      resize: vertical;
      height: 100px;
       margin-bottom: 10px; /* Added margin bottom */
    }
    button {
      cursor: pointer;
       margin-top: 5px; /* Adjusted margin top */
       width: auto; /* Auto width for buttons */
       padding: 10px 15px; /* Larger padding for buttons */
       font-weight: bold;
    }
     button.delete-btn {
        background: red;
        color: white;
        border: none;
        margin-left: 10px;
      }
      button.delete-btn:hover {
        background: darkred;
      }

    #errorMessage {
      color: red;
      display: none;
      margin-top: 10px;
    }
    #adminControls {
      display: none;
    }

      /* Styles for Product List */
      #productList {
          margin-top: 20px;
          text-align: center; /* Center the button */
      }
      .product-item {
          border: 1px solid #ccc;
          padding: 10px;
          margin-bottom: 10px;
          border-radius: 5px;
          background-color: #fff;
          display: flex;
          align-items: center;
          gap: 15px;
          word-break: break-word;
      }
       .product-item img {
          width: 60px;
          height: auto;
          border-radius: 4px;
      }
       .product-details {
           flex-grow: 1;
       }
        .product-details h4 {
           margin: 0 0 5px 0;
        }
         .product-details p {
            margin: 0 0 3px 0;
            font-size: 0.9em;
            color: #555;
         }
          .product-details a {
             color: #0073e6;
             text-decoration: none;
          }
           .product-details a:hover {
              text-decoration: underline;
           }

        /* Green button style (used for the Home button and Product Database) */
         .green-button {
             background-color: #4CAF50;
             color: white;
             padding: 10px 15px;
             border: none;
             border-radius: 5px;
             cursor: pointer;
             font-size: 16px;
         }
         .green-button:hover {
             background-color: #45a049;
         }

       /* Style for the Tax Portal button - now in Taxation section */
       .tax-portal-button {
          margin-top: 0; /* Remove margin-top as it's in its own box */
          width: 100%; /* Make it full width in its box */
          display: block; /* Make it a block element */
       }

        /* Style for the Product Database button */
        .product-database-button {
           display: inline-block; /* Make it inline-block to respect text-align: center */
           width: auto; /* Override width: 100% from general button style */
        }

        /* Style for the Save Payment Info button */
        .save-payment-button {
            background-color: #0073e6; /* Blue */
            color: white;
            margin-top: 15px; /* Add space above */
        }
         .save-payment-button:hover {
            background-color: #005bb5;
         }

         /* Styles for payment method inputs */
         .payment-input-group {
            margin-bottom: 15px; /* Space between payment method groups */
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
         }
         .payment-input-group label {
            font-weight: normal; /* Less bold than section labels */
            margin-bottom: 5px;
         }
         .payment-input-group input {
            margin-bottom: 5px; /* Space between input and button */
         }
         .payment-input-group button {
             width: 100%; /* Make buttons full width within the group */
             padding: 8px 10px; /* Slightly smaller padding for these buttons */
             font-weight: normal;
             margin-top: 0; /* Remove extra margin-top */
             /* Default button style, overridden by specific classes below */
             background-color: #eee;
             border: 1px solid #ccc;
             color: #333;
         }
         .payment-input-group button:hover {
             background-color: #ddd;
         }
         .payment-input-group h4 {
             margin-top: 0;
             margin-bottom: 10px;
             color: #333;
         }

         /* Specific Button Styles with Colors and Emojis */
         .venmo-button {
             background-color: #008CFF; /* Venmo Blue */
             color: white;
             border: none;
         }
         .venmo-button:hover {
             background-color: #0073e6;
         }
         .google-pay-button {
             background-color: #5F6368; /* Google Grey */
             color: white;
             border: none;
         }
         .google-pay-button:hover {
             background-color: #45494e;
         }
         .paypal-button {
             background-color: #003087; /* PayPal Blue */
             color: white;
             border: none;
         }
         .paypal-button:hover {
             background-color: #00206a;
         }
         .cashapp-button {
             background-color: #00C244; /* Cash App Green */
             color: white;
             border: none;
         }
         .cashapp-button:hover {
             background-color: #00a137;
         }
         .apple-pay-button {
             background-color: #000000; /* Black */
             color: white;
             border: none;
         }
         .apple-pay-button:hover {
             background-color: #333333;
         }


  </style>
</head>
<body>
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <h1 style="margin: 0;">üîí Admin Panel üîë</h1>
    <button onclick="location.href='index.html'" class="green-button">üè† Home</button>
  </div>

  <div class="box">
    <label for="walletAddress">Enter Admin Wallet Address:</label>
    <input type="text" id="walletAddress" placeholder="0x..." />
    <button id="authenticateBtn" class="connect-btn">üîê Authenticate</button>
     <p id="errorMessage" style="color: red;">Authentication failed. Invalid wallet address.</p>
  </div>

  <div class="box" id="regionBox" style="display: none;">
    <h2>üåç Region Detection</h2>
    <p>This section will automatically detect the admin's region for tax calculations and compliance.</p>
    <p id="regionOutput">Detecting region...</p>
  </div>

  <div id="adminControls">
    <div class="box">
      <h2>üì¶ Add/Manage Products</h2>

      <h3>Add a New Product</h3>
      <label>üìù Product Name: <input id="productName" /></label>
      <label>üßæ Description: <textarea id="productDescription"></textarea></label>
      <label>üîë SEO Keywords (comma-separated): <input id="productKeywords" /></label>
      <label>üí∞ ETH Price: <input id="ethPrice" type="number" step="any" /></label>
      <label>üíµ USD Equivalent: <input id="usdPrice" readonly /></label>
      <label>üóÇÔ∏è Upload Image: <input type="file" id="productImageFile" accept="image/*" /></label>

      <hr style="margin: 20px 0;">

      <h3>Add an NFT Listing (Optional)</h3>
      <p>Fill these fields instead of/in addition to the above if listing an NFT.</p>
      <label>üîó NFT Contract Address: <input id="nftContractAddress" placeholder="0x..." /></label>
      <label>üÜî NFT Token ID: <input id="nftTokenId" type="number" step="1" /></label>
       <label>üîë SEO Keywords (comma-separated): <input id="nftKeywords" /></label>
        <label>üí∞ ETH Price: <input id="nftEthPrice" type="number" step="any" /></label>
        <label>üíµ USD Equivalent: <input id="nftUsdPrice" readonly /></label>


      <hr style="margin: 20px 0;">

      <h3>Add Social Media/External Links (Optional)</h3>
      <label>üì∑ Instagram URL: <input id="instagramUrl" placeholder="https://www.instagram.com/..." /></label>
      <label>üï∫ TikTok URL: <input id="tiktokUrl" placeholder="https://www.tiktok.com/@..." /></label>
      <label>üåê Other Link: <input id="otherLinkUrl" placeholder="https://..." /></label>
       <label>üìù Link Title: <input id="linkTitle" placeholder="e.g., Artist Website" /></label>
       <label>üìã Link Details: <textarea id="linkDetails" placeholder="Brief description of the link..."></textarea></label>
       <label>üîë SEO Keywords (comma-separated): <input id="socialLinkKeywords" /></label>
       <label>üí∞ ETH Price: <input id="socialLinkEthPrice" type="number" step="any" /></label>
       <label>üíµ USD Equivalent: <input id="socialLinkUsdPrice" readonly /></label>


      <button id="addProductBtn" class="green-button">‚ûï Add Product</button>
      <button id="clearFieldsBtn" class="connect-btn">üßπ Clear Fields</button>


      <h3 style="margin-top: 30px;">üóÉÔ∏è Current Product Listings</h3>
      <div id="productList">
           <button onclick="location.href='product_database.html'" class="green-button product-database-button">üìÇ Product Database</button>
          </div>
        </div>

    <div class="box">
      <h2>üì¨ Orders</h2>
      <button id="orderNotificationBtn">üîî New Orders <span class="notification-counter" id="orderCounter">0</span></button>
      <button id="deleteAllOrdersBtn" class="delete-btn">üóëÔ∏è Delete All Orders</button>
      <p>Total Order Value (Estimate): $<span id="adminOrderValue">0</span></p>
      <div id="orderListContainer" style="display: none;">
        <h4>Recent Orders</h4>
        <ul id="orderList"></ul>
      </div>
    </div>

    <div id="supportMessagesContainer" class="box">
      <h2>üí¨ Support Messages</h2>
      <ul id="supportMessageList"></ul>
      <button id="deleteAllMessagesBtn" class="delete-btn">üóëÔ∏è Delete All Messages</button>

      <hr style="margin: 20px 0;">

      <h3>üí≥ Payment Addresses (for Seller)</h3>
      <p>Enter the addresses/identifiers for receiving payments via these methods.</p>

      <div class="payment-input-group">
          <h4>Venmo</h4>
          <label for="venmoAddress">Venmo Handle/Phone/Email:</label>
          <input type="text" id="venmoAddress" placeholder="@handle, phone, or email" />
           <button class="venmo-button" onclick="alert('Payment integration for Venmo needs to be implemented.')">üí∏ Pay via Venmo</button>
      </div>

      <div class="payment-input-group">
          <h4>Google Pay</h4>
          <label for="googlePayAddress">Google Pay Identifier:</label>
          <input type="text" id="googlePayAddress" placeholder="Email or phone number" />
          <button class="google-pay-button" onclick="alert('Payment integration for Google Pay needs to be implemented.')">üí≥ Pay via Google Pay</button>
      </div>

      <div class="payment-input-group">
          <h4>PayPal</h4>
          <label for="paypalAddress">PayPal Email or Phone:</label>
          <input type="text" id="paypalAddress" placeholder="Email or phone number" />
          <button class="paypal-button" onclick="alert('Payment integration for PayPal needs to be implemented.')">üÖøÔ∏è Pay via PayPal</button>
      </div>

      <div class="payment-input-group">
          <h4>Cash App</h4>
          <label for="cashAppAddress">Cash App Cashtag:</label>
          <input type="text" id="cashAppAddress" placeholder="$cashtag" />
          <button class="cashapp-button" onclick="alert('Payment integration for Cash App needs to be implemented.')">üí∞ Pay via Cash App</button>
      </div>

      <div class="payment-input-group">
          <h4>Apple Pay</h4>
          <p>Apple Pay typically requires specific web integration (Apple Pay JS). You can list an identifier here if applicable, but direct linking is complex.</p>
          <label for="applePayIdentifier">Apple Pay Identifier (Optional):</label>
          <input type="text" id="applePayIdentifier" placeholder="Email or phone number (if used)" />
           <button class="apple-pay-button" onclick="alert('Apple Pay integration is complex and needs specific setup.')">Ô£ø Pay via Apple Pay</button>
      </div>

      <button id="savePaymentInfoBtn" class="green-button save-payment-button">üíæ Save Payment Info</button>

    </div>

    <div class="box">
        <h2>üìä Taxation</h2>
        <button onclick="location.href='crypto_tax.html'" class="green-button tax-portal-button">üí∞ Tax Portal</button>
    </div>
    </div>

<script>
// Firebase Configuration (REPLACE WITH YOUR ACTUAL CONFIG)
const firebaseConfig = {
  apiKey: "YOUR_API_KEY", // Replace with your API Key
  authDomain: "YOUR_AUTH_DOMAIN", // Replace with your Auth Domain
  projectId: "YOUR_PROJECT_ID", // Replace with your Project ID
  storageBucket: "YOUR_STORAGE_BUCKET", // Replace with your Storage Bucket
  messagingSenderId: "YOUR_MESSAGING_SENDER_ID", // Replace with your Messaging Sender ID
  appId: "YOUR_APP_ID" // Replace with your App ID
};

// Initialize Firebase (Copied from other files)
if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
}
const db = firebase.firestore(); // Firestore reference
const storage = firebase.storage(); // Storage reference

// ‚ö° ADMIN WALLET ADDRESS (Change this if selling the marketplace)
const ADMIN_WALLET = "0x99fd24a80f98607faf53cc24dda0af9bb967bc8b"; // Replace with your actual admin wallet


let ethToUsd = 0;

// Fetch ETH to USD price
async function fetchEthUsdPrice() {
  try {
    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
    const data = await response.json();
    ethToUsd = parseFloat(data.ethereum.usd);
     // Update USD equivalent fields on load if ETH price is already entered
     updateUsdFields();

    return ethToUsd;
  } catch (error) {
    console.error('Error fetching ETH price:', error);
    ethToUsd = 0;
    return null;
  }
}

// Function to update all USD equivalent fields based on their corresponding ETH input
function updateUsdFields() {
     // Update USD for main product ETH price
    const ethInput = document.getElementById('ethPrice');
    const usdOutput = document.getElementById('usdPrice');
    const ethAmount = parseFloat(ethInput?.value);
    if (ethInput && usdOutput) {
        if (!isNaN(ethAmount) && ethToUsd) {
            usdOutput.value = `$${(ethAmount * ethToUsd).toFixed(2)}`;
        } else {
            usdOutput.value = '';
        }
    }

     // Update USD for NFT ETH price
     const nftEthInput = document.getElementById('nftEthPrice');
     const nftUsdOutput = document.getElementById('nftUsdPrice');
     const nftEthAmount = parseFloat(nftEthInput?.value);
     if (nftEthInput && nftUsdOutput) {
         if (!isNaN(nftEthAmount) && ethToUsd) {
             nftUsdOutput.value = `$${(nftEthAmount * ethToUsd).toFixed(2)}`;
         } else {
             nftUsdOutput.value = '';
         }
     }

     // Update USD for Social Link ETH price
     const socialLinkEthInput = document.getElementById('socialLinkEthPrice');
     const socialLinkUsdOutput = document.getElementById('socialLinkUsdPrice');
     const socialLinkEthAmount = parseFloat(socialLinkEthInput?.value);
     if (socialLinkEthInput && socialLinkUsdOutput) {
         if (!isNaN(socialLinkEthAmount) && ethToUsd) {
             socialLinkUsdOutput.value = `$${(socialLinkEthAmount * ethToUsd).toFixed(2)}`;
         } else {
             socialLinkUsdOutput.value = '';
         }
     }
}


// Listen for changes in all ETH price inputs to update their USD equivalent
document.getElementById('ethPrice')?.addEventListener('input', updateUsdFields);
document.getElementById('nftEthPrice')?.addEventListener('input', updateUsdFields);
document.getElementById('socialLinkEthPrice')?.addEventListener('input', updateUsdFields);


// Upload image to Firebase Storage
async function uploadImage(file) {
    if (!file) return null;
    const storageRef = storage.ref();
    // Create a unique filename (e.g., using timestamp and original name)
    const filename = `${Date.now()}_${file.name}`;
    const imageRef = storageRef.child(`product_images/${filename}`); // Store in 'product_images' folder
    await imageRef.put(file);
    const downloadURL = await imageRef.getDownloadURL();
    return downloadURL;
}

// Add Product (Now saves to Firestore)
async function addProduct() {
    const name = document.getElementById('productName').value.trim();
    const description = document.getElementById('productDescription').value.trim();

    // Keywords from all sections
    const productKeywords = document.getElementById('productKeywords').value.trim().split(',').map(k => k.trim()).filter(k => k !== '');
    const nftKeywords = document.getElementById('nftKeywords').value.trim().split(',').map(k => k.trim()).filter(k => k !== '');
    const socialLinkKeywords = document.getElementById('socialLinkKeywords').value.trim().split(',').map(k => k.trim()).filter(k => k !== '');
    const allKeywords = [...productKeywords, ...nftKeywords, ...socialLinkKeywords]; // Combine keywords

    // Prices from all sections (prioritize standard, then NFT, then social link if multiple entered)
    const ethPriceMain = parseFloat(document.getElementById('ethPrice').value);
    const ethPriceNft = parseFloat(document.getElementById('nftEthPrice').value);
    const ethPriceSocial = parseFloat(document.getElementById('socialLinkEthPrice').value);

     let finalEthPrice = null;
     if (!isNaN(ethPriceMain)) {
         finalEthPrice = ethPriceMain;
     } else if (!isNaN(ethPriceNft)) {
         finalEthPrice = nftEthPrice;
     } else if (!isNaN(ethPriceSocial)) {
         finalEthPrice = socialLinkEthPrice;
     }


    const imageFile = document.getElementById('productImageFile').files[0];

    // NFT Fields
    const nftContractAddress = document.getElementById('nftContractAddress').value.trim();
    const nftTokenId = document.getElementById('nftTokenId').value.trim(); // Keep as string for now, parse if needed

    // Social Media Links
    const instagramUrl = document.getElementById('instagramUrl').value.trim();
    const tiktokUrl = document.getElementById('tiktokUrl').value.trim();
    const otherLinkUrl = document.getElementById('otherLinkUrl').value.trim();
    const linkTitle = document.getElementById('linkTitle').value.trim(); // New: Link Title
    const linkDetails = document.getElementById('linkDetails').value.trim(); // New: Link Details


    // Basic validation
    if (!name || !description) {
        alert('Please fill in Product Name and Description.');
        return;
    }
     // Validate if at least one price OR NFT details are provided
     if (isNaN(finalEthPrice) && (!nftContractAddress || !nftTokenId)) {
         alert('Please enter an ETH Price (in any section) or fill in NFT Contract Address and Token ID.');
         return;
      }
      // Validation for conflicting input (basic)
      if (imageFile && (nftContractAddress || nftTokenId)) {
           alert('Please list either a standard product with image OR an NFT, not both with an image upload.');
           return;
      }

      // Basic NFT format validation (can be improved with regex)
      if (nftContractAddress && !ethers.utils.isAddress(nftContractAddress)) {
          alert('Invalid NFT Contract Address format.');
          return;
      }
       if (nftTokenId && isNaN(parseInt(nftTokenId))) {
           alert('Invalid NFT Token ID. Must be a number.');
           return;
        }


    let imageUrl = null;
    if (imageFile) {
        // Upload image if it's a standard product with an image
        imageUrl = await uploadImage(imageFile);
    }
     // Note: For NFTs, you would typically fetch the image URL from metadata
     // using the contract address and token ID here. This is NOT implemented.


    // Get the connected admin wallet address from the input field after authentication
    const sellerWallet = document.getElementById('walletAddress').value.trim().toLowerCase();
    if (!sellerWallet) {
        alert('Admin wallet not authenticated.');
        return;
    }


    const productData = {
        name: name,
        description: description,
        keywords: allKeywords, // Save combined keywords
        ethPrice: finalEthPrice, // Save the determined ETH price
        imageUrl: imageUrl, // Store image URL from upload

        // NFT Data (Store if provided)
        nftContractAddress: nftContractAddress || null,
        nftTokenId: nftTokenId || null,
        // nftMetadataUrl: '...' // You would ideally store a URL to NFT metadata here

        // Social Media Links (Store if provided)
        instagramUrl: instagramUrl || null,
        tiktokUrl: tiktokUrl || null,
        otherLinkUrl: otherLinkUrl || null,
        linkTitle: linkTitle || null, // New: Link Title
        linkDetails: linkDetails || null, // New: Link Details
         // Add other social media fields here

        sellerWallet: sellerWallet, // Store the seller's wallet
        timestamp: firebase.firestore.FieldValue.serverTimestamp() // Add server timestamp
    };

    try {
        // Add the product data to the 'products' collection in Firestore
        await db.collection('products').add(productData);
        alert('Product added successfully!');
        clearFields(); // Clear form fields after successful addition
        // displayProducts(); // No longer displaying directly on this page
    } catch (error) {
        console.error("Error adding product:", error);
        alert('Error adding product: ' + error.message);
    }
}


// This function is no longer needed to display products on this page
// async function displayProducts() {
//     const productListDiv = document.getElementById('productList');
//     productListDiv.innerHTML = '<p>Loading products...</p>'; // Loading indicator

//     try {
//         const productsSnapshot = await db.collection('products').orderBy('timestamp', 'desc').get();
//         const products = productsSnapshot.docs.map(doc => ({
//             id: doc.id,
//             ...doc.data()
//         }));

//         productListDiv.innerHTML = '';

//         if (products.length === 0) {
//             productListDiv.innerHTML = '<p>No products listed yet.</p>';
//             return;
//         }

//         products.forEach(product => {
//             const itemDiv = document.createElement('div');
//             itemDiv.className = 'product-item';

//             const usdValue = (ethToUsd && product.ethPrice) ? (product.ethPrice * ethToUsd).toFixed(2) : 'N/A';

//             let detailsHTML = `
//                 <h4>${product.name || 'Untitled Product'}</h4>
//                  <p>Description: ${product.description ? product.description.substring(0, 150) + (product.description.length > 150 ? '...' : '') : 'N/A'}</p>
//                  <p>Seller: ${product.sellerWallet ? product.sellerWallet.slice(0, 6) + '...' + product.sellerWallet.slice(-4) : 'N/A'}</p>
//             `;

//              if (product.keywords && product.keywords.length > 0) {
//                   detailsHTML += `<p>Keywords: ${product.keywords.join(', ')}</p>`;
//              }

//             if (product.ethPrice !== null && !isNaN(product.ethPrice)) {
//                  detailsHTML += `<p>Price: ${product.ethPrice} ETH ${ethToUsd ? '(~$' + usdValue + ')' : ''}</p>`;
//             }

//             if (product.nftContractAddress && product.nftTokenId) {
//                  detailsHTML += `<p>NFT: Contract - ${product.nftContractAddress.slice(0, 6) + '...' + product.nftContractAddress.slice(-4)}, Token ID - ${product.nftTokenId}</p>`;
//             }

//              let socialLinksHTML = '';
//              if (product.instagramUrl) socialLinksHTML += `<a href="${product.instagramUrl}" target="_blank">Instagram</a> `;
//              if (product.tiktokUrl) socialLinksHTML += `<a href="${product.tiktokUrl}" target="_blank">TikTok</a> `;
//              if (product.otherLinkUrl) socialLinksHTML += `<a href="${product.otherLinkUrl}" target="_blank">Other Link</a>`;

//              if (product.linkTitle) socialLinksHTML += `<br>Link Title: ${product.linkTitle}`;
//              if (product.linkDetails) socialLinksHTML += `<br>Link Details: ${product.linkDetails}`;


//              if (socialLinksHTML) {
//                  detailsHTML += `<p>Links: ${socialLinksHTML}</p>`;
//              }


//             itemDiv.innerHTML = `
//                  ${product.imageUrl ? `<img src="${product.imageUrl}" alt="${product.name}">` : ''}
//                 <div class="product-details">
//                     ${detailsHTML}
//                 </div>
//                  <button onclick="deleteProduct('${product.id}')" class="delete-btn">üóëÔ∏è Delete</button>
//             `;
//             productListDiv.appendChild(itemDiv);
//         });

//     } catch (error) {
//         console.error("Error fetching products:", error);
//         productListDiv.innerHTML = '<p style="color: red;">Error loading products.</p>';
//     }
// }

// This function is no longer needed to delete products from this page display
// async function deleteProduct(productId) {
//     if (confirm('Are you sure you want to delete this product?')) {
//         try {
//             await db.collection('products').doc(productId).delete();
//             alert('Product deleted successfully!');
//             displayProducts(); // Refresh the product list
//         } catch (error) {
//             console.error("Error deleting product:", error);
//             alert('Error deleting product: ' + error.message);
//         }
//     }
// }


// Clear form fields
function clearFields() {
    document.getElementById('productName').value = '';
    document.getElementById('productDescription').value = '';

    document.getElementById('productKeywords').value = '';
    document.getElementById('ethPrice').value = '';
    document.getElementById('usdPrice').value = '';
    document.getElementById('productImageFile').value = ''; // Clear file input

    document.getElementById('nftContractAddress').value = '';
    document.getElementById('nftTokenId').value = '';
    document.getElementById('nftKeywords').value = '';
    document.getElementById('nftEthPrice').value = '';
    document.getElementById('nftUsdPrice').value = '';

    document.getElementById('instagramUrl').value = '';
    document.getElementById('tiktokUrl').value = '';
    document.getElementById('otherLinkUrl').value = '';
    document.getElementById('linkTitle').value = '';
    document.getElementById('linkDetails').value = '';
    document.getElementById('socialLinkKeywords').value = '';
    document.getElementById('socialLinkEthPrice').value = '';
    document.getElementById('socialLinkUsdPrice').value = '';
    // Clear other social media fields
}


// Load Support Messages (Assumes messages are in Firestore)
async function loadSupportMessages() {
    const supportList = document.getElementById('supportMessageList');
     if (!supportList) return; // Exit if the element doesn't exist

    supportList.innerHTML = '<p>Loading messages...</p>';

    try {
        // Assuming support messages are stored in a 'supportMessages' collection
        const messagesSnapshot = await db.collection('supportMessages').orderBy('timestamp', 'desc').get();
        const messages = messagesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        supportList.innerHTML = ''; // Clear current list

        if (messages.length === 0) {
            supportList.innerHTML = '<p>No support messages.</p>';
            return;
        }

        messages.forEach(msg => {
            const li = document.createElement('li');
             const msgDate = msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleString() : 'N/A';
            li.innerHTML = `<strong>${msg.name || 'Anonymous'}</strong> (${msgDate}): ${msg.message || 'No message content'}`;
            supportList.appendChild(li);
        });

    } catch (error) {
        console.error("Error loading support messages:", error);
        supportList.innerHTML = '<p style="color: red;">Error loading messages.</p>';
    }
}

// Delete All Support Messages (Assumes messages are in Firestore)
async function deleteAllMessages() {
     if (!document.getElementById('supportMessageList')) return; // Exit if the element doesn't exist

    if (confirm('Are you sure you want to delete all support messages? This cannot be undone.')) {
        try {
            const snapshot = await db.collection('supportMessages').get();
            const batch = db.batch();
            snapshot.docs.forEach((doc) => {
                batch.delete(doc.ref);
            });
            await batch.commit();
            alert('All support messages deleted.');
            loadSupportMessages(); // Refresh the list
        } catch (error) {
            console.error("Error deleting all messages:", error);
            alert('Error deleting all messages: ' + error.message);
        }
    }
}


// Load Orders (Assumes orders are in Firestore)
async function loadOrders() {
    const orderList = document.getElementById('orderList');
    const orderCounter = document.getElementById('orderCounter');
     if (!orderList || !orderCounter) return; // Exit if elements don't exist


    orderList.innerHTML = '<p>Loading orders...</p>';

    try {
        // Assuming orders are stored in an 'orders' collection
        const ordersSnapshot = await db.collection('orders').orderBy('timestamp', 'desc').get();
        const orders = ordersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        orderList.innerHTML = ''; // Clear current list
        orderCounter.textContent = orders.length; // Update counter

        if (orders.length === 0) {
            orderList.innerHTML = '<p>No recent orders.</p>';
            return;
        }

        let totalOrderValueUsd = 0;

        orders.forEach(order => {
            const li = document.createElement('li');
            const orderDate = order.timestamp ? new Date(order.timestamp.toDate()).toLocaleString() : 'N/A';
            const buyerShort = order.buyerWallet ? order.buyerWallet.slice(0, 6) + '...' + order.buyerWallet.slice(-4) : 'N/A';
             const totalEth = order.totalEth || 0;
             const orderValueUsd = ethToUsd ? (totalEth * ethToUsd).toFixed(2) : 'N/A';

             if (ethToUsd && !isNaN(parseFloat(orderValueUsd))) {
                 totalOrderValueUsd += parseFloat(orderValueUsd);
             }


            li.innerHTML = `
                  <strong>Order for:</strong> ${order.productName || 'N/A'} (x${order.quantity || 1})<br>
                  <strong>Buyer:</strong> ${buyerShort}<br>
                  <strong>Total ETH:</strong> ${totalEth} ${ethToUsd ? '(~$' + orderValueUsd + ')' : ''}<br>
                  <strong>Date:</strong> ${orderDate}
                  `;
            orderList.appendChild(li);
        });

         // Update total order value display
         document.getElementById("adminOrderValue").textContent = ethToUsd ? totalOrderValueUsd.toFixed(2) : 'N/A';


    } catch (error) {
        console.error("Error loading orders:", error);
        orderList.innerHTML = '<p style="color: red;">Error loading orders.</p>';
        orderCounter.textContent = 'Error';
    }
}

// Delete All Orders (Assumes orders are in Firestore)
async function deleteAllOrders() {
     if (!document.getElementById('orderList')) return; // Exit if the element doesn't exist

    if (confirm('Are you sure you want to delete all orders? This cannot be undone.')) {
        try {
            const snapshot = await db.collection('orders').get();
            const batch = db.batch();
            snapshot.docs.forEach((doc) => {
                batch.delete(doc.ref);
            });
            await batch.commit();
            alert('All orders deleted.');
            loadOrders(); // Refresh the list
        } catch (error) {
            console.error("Error deleting all orders:", error);
            alert('Error deleting all orders: ' + error.message);
        }
    }
}


// Function to detect region (kept from original)
async function detectRegion() {
    const regionOutput = document.getElementById('regionOutput');
    const regionBox = document.getElementById('regionBox');
     if (!regionOutput || !regionBox) return; // Exit if elements don't exist

     regionBox.style.display = 'block'; // Show the region box if elements exist

     try {
       const res = await fetch('https://ipapi.co/json/');
       const data = await res.json();
       const region = `${data.city || 'N/A'}, ${data.region || 'N/A'}, ${data.country_name || 'N/A'}`;
       regionOutput.innerText = `Region: ${region}`;
     } catch (error) {
       regionOutput.innerText = 'Could not detect region.';
       console.error('Region detection failed:', error);
     }
}

// --- Payment Info Functions ---

// Function to save payment addresses to Firestore
async function savePaymentInfo() {
    const venmo = document.getElementById('venmoAddress').value.trim();
    const googlePay = document.getElementById('googlePayAddress').value.trim();
    const paypal = document.getElementById('paypalAddress').value.trim();
    const cashApp = document.getElementById('cashAppAddress').value.trim();
    const applePay = document.getElementById('applePayIdentifier').value.trim();

    // Assuming you have a fixed document to store admin settings, e.g., 'adminSettings' with doc ID 'paymentInfo'
    const adminSettingsRef = db.collection('adminSettings').doc('paymentInfo');

    try {
        await adminSettingsRef.set({
            venmo: venmo,
            googlePay: googlePay,
            paypal: paypal,
            cashApp: cashApp,
            applePay: applePay,
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp() // Optional: add timestamp
        }, { merge: true }); // Use merge: true to update existing fields without overwriting the whole document
        alert('Payment information saved successfully!');
    } catch (error) {
        console.error("Error saving payment info:", error);
        alert('Error saving payment information: ' + error.message);
    }
}

// Function to load payment addresses from Firestore
async function loadPaymentInfo() {
     // Assuming you have a fixed document to store admin settings, e.g., 'adminSettings' with doc ID 'paymentInfo'
     const adminSettingsRef = db.collection('adminSettings').doc('paymentInfo');

     try {
         const doc = await adminSettingsRef.get();
         if (doc.exists) {
             const data = doc.data();
             document.getElementById('venmoAddress').value = data.venmo || '';
             document.getElementById('googlePayAddress').value = data.googlePay || '';
             document.getElementById('paypalAddress').value = data.paypal || '';
             document.getElementById('cashAppAddress').value = data.cashApp || '';
             document.getElementById('applePayIdentifier').value = data.applePay || '';
         } else {
             console.log("No payment information found in Firestore.");
             // Optionally clear fields if no data exists
             document.getElementById('venmoAddress').value = '';
             document.getElementById('googlePayAddress').value = '';
             document.getElementById('paypalAddress').value = '';
             document.getElementById('cashAppAddress').value = '';
             document.getElementById('applePayIdentifier').value = '';
         }
     } catch (error) {
         console.error("Error loading payment info:", error);
         alert('Error loading payment information: ' + error.message);
     }
}


// --- Event Listeners and Initialization ---

document.addEventListener('DOMContentLoaded', async () => {

    // Fetch ETH price on load
    fetchEthUsdPrice();

    // Region Detection on load
    detectRegion();

    // Admin Authentication
    document.getElementById('authenticateBtn')?.addEventListener('click', function() {
      const enteredWallet = document.getElementById('walletAddress').value.trim().toLowerCase();
      const errorMessage = document.getElementById('errorMessage');
      const adminControls = document.getElementById('adminControls');

      if (enteredWallet === ADMIN_WALLET.toLowerCase()) {
        adminControls.style.display = 'block'; // Show admin controls
        errorMessage.style.display = 'none'; // Hide error message

        // Load data after successful authentication
        // displayProducts(); // No longer displaying directly on this page
        loadOrders(); // Load orders from Firestore
        loadSupportMessages(); // Load support messages from Firestore
        loadPaymentInfo(); // Load payment info when admin authenticates


      } else {
        errorMessage.style.display = 'block'; // Show error message
        adminControls.style.display = 'none'; // Hide admin controls
         // Clear any previously loaded data if auth fails
         document.getElementById('productList').innerHTML = '<button onclick="location.href=\'product_database.html\'" class="green-button product-database-button">üìÇ Product Database</button>'; // Ensure button is there even on auth fail
         document.getElementById('orderList').innerHTML = '<p>Authenticate to see orders.</p>';
         document.getElementById('supportMessageList').innerHTML = '<p>Authenticate to see messages.</p>';
         document.getElementById('orderCounter').textContent = '0';
         document.getElementById("adminOrderValue").textContent = '0';
         // Clear payment info fields if auth fails
         document.getElementById('venmoAddress').value = '';
         document.getElementById('googlePayAddress').value = '';
         document.getElementById('paypalAddress').value = '';
         document.getElementById('cashAppAddress').value = '';
         document.getElementById('applePayIdentifier').value = '';
      }
    });

    // Add Product button listener
    document.getElementById('addProductBtn')?.addEventListener('click', addProduct);

    // Clear Fields button listener
    document.getElementById('clearFieldsBtn')?.addEventListener('click', clearFields);

    // Save Payment Info button listener
    document.getElementById('savePaymentInfoBtn')?.addEventListener('click', savePaymentInfo);


    // Order Notification button listener
    document.getElementById('orderNotificationBtn')?.addEventListener('click', () => {
      const orderListContainer = document.getElementById('orderListContainer');
      if (orderListContainer) {
          const isVisible = orderListContainer.style.display === 'block';
          orderListContainer.style.display = isVisible ? 'none' : 'block';
          if (!isVisible) loadOrders(); // Reload orders if showing the container
      }
    });

    // Delete All Orders button listener
    document.getElementById('deleteAllOrdersBtn')?.addEventListener('click', deleteAllOrders);

    // Delete All Messages button listener
    document.getElementById('deleteAllMessagesBtn')?.addEventListener('click', deleteAllMessages);


    // Re-add the ETH price input listener for the Add Product sections
    const adminEthInput = document.getElementById('ethPrice');
    const adminUsdOutput = document.getElementById('usdPrice');

    if (adminEthInput && adminUsdOutput) {
        adminEthInput.addEventListener('input', () => { // Removed async as rate is already fetched
            const ethAmount = parseFloat(adminEthInput.value);
            if (!isNaN(ethAmount) && ethToUsd) { // Use ethToUsd global variable
                adminUsdOutput.value = `$${(ethAmount * ethToUsd).toFixed(2)}`;
            } else {
                adminUsdOutput.value = '';
            }
        });
    }


    // Initial display state (hide admin controls until authenticated)
    document.getElementById('adminControls').style.display = 'none';
     document.getElementById('errorMessage').style.display = 'none';
     // Place the product database button on initial load
     document.getElementById('productList').innerHTML = '<button onclick="location.href=\'product_database.html\'" class="green-button product-database-button">üìÇ Product Database</button>';
});

// --- Admin Panel Script Functions (Need Firestore Integration) ---

// NOTE: The existing admin functions (addProduct, deleteProduct, loadSupportMessages, loadOrders, updateAdminOrderTotals)
// are currently using localStorage as per the original admin.txt file.
// To fully integrate Firebase for the admin panel, these functions would need to be updated
// to use Firebase Firestore and Storage, similar to the new user panel functions.
// This code keeps the original localStorage logic for these admin functions for now.

// Admin Add Product (still uses localStorage)
async function addProduct() {
  const name = document.getElementById('productName').value.trim();
  const description = document.getElementById('productDescription').value.trim();
  const keywords = document.getElementById('productKeywords').value.trim().split(',').map(k => k.trim()).filter(k => k !== ''); // Filter empty keywords
  const ethPrice = parseFloat(document.getElementById('ethPrice').value);
  const file = document.getElementById('productImageFile').files[0];

  if (!name || !description || isNaN(ethPrice) || !file) {
    alert('Fill out everything and select an image!');
    return;
  }

  // This is using localStorage - consider updating to Firebase Storage
  // const image = await toBase64(file); // This function converts to Base64

  // Placeholder for image upload to Firebase Storage
  let imageUrl = '';
   try {
       const storageRef = storage.ref('product_images/' + Date.now() + '-' + file.name);
       const snapshot = await storageRef.put(file);
       imageUrl = await snapshot.ref.getDownloadURL();
       console.log("Admin image uploaded:", imageUrl);
   } catch (error) {
      console.error("Admin image upload error:", error);
      alert('Error uploading image: ' + error.message);
      return; // Stop if image upload fails
   }


  // This is using localStorage - consider updating to Firebase Firestore
  const product = { name, description, keywords, ethPrice, imageUrl: imageUrl }; // Use imageUrl
  const products = JSON.parse(localStorage.getItem('products')) || [];
  products.push(product);
  localStorage.setItem('products', JSON.stringify(products));
  // displayProducts(); // Admin display is hidden
  clearFields(); // clear fields after adding
  alert('Product added to local storage (Admin view)! Consider updating to Firebase.'); // Alert for clarity
}

// Admin Delete Product (still uses localStorage)
function deleteProduct(index) {
  const products = JSON.parse(localStorage.getItem('products')) || [];
  if (index >= 0 && index < products.length) {
      products.splice(index, 1);
      localStorage.setItem('products', JSON.stringify(products));
      // displayProducts(); // Admin display is hidden
      alert('Product deleted from local storage (Admin view)! Consider updating to Firebase.'); // Alert for clarity
  }
}

// Admin Load Support Messages (still uses localStorage)
function loadSupportMessages() {
    const supportList = document.getElementById('supportMessageList');
    if (!supportList) return;
    const messages = JSON.parse(localStorage.getItem('supportMessages')) || [];
    supportList.innerHTML = '';
     if (messages.length === 0) {
         supportList.innerHTML = '<p>No support messages.</p>';
     } else {
        messages.forEach(msg => {
          const li = document.createElement('li');
          li.textContent = `${msg.name}: ${msg.message}`;
          supportList.appendChild(li);
        });
     }
}

// Admin Load Orders (still uses localStorage)
function loadOrders() {
    const orderList = document.getElementById('orderList');
    const orderCounter = document.getElementById('orderCounter');
    if (!orderList || !orderCounter) return;
    const orders = JSON.parse(localStorage.getItem('orders')) || [];
    orderCounter.textContent = orders.length;
    orderList.innerHTML = '';
     if (orders.length === 0) {
        orderList.innerHTML = '<p>No recent orders.</p>';
     } else {
        orders.forEach(order => {
          const li = document.createElement('li');
          // Adjust text content based on your localStorage order structure
          li.textContent = `Order for ${order.productName} (x${order.quantity}) to ${order.address}, ${order.city}`;
          orderList.appendChild(li);
        });
     }
    updateAdminOrderTotals(); // Update totals after loading orders
}

// Admin Update Order Totals (still uses localStorage)
function updateAdminOrderTotals() {
  const orders = JSON.parse(localStorage.getItem("orders")) || [];
  // Note: This calculation still assumes products and ETH price are in localStorage
  // It needs significant updates to work with Firestore and current ETH price rate
  let total = 0;
   const products = JSON.parse(localStorage.getItem("products")) || []; // Assuming products are needed for price

  orders.forEach(order => {
    const product = products.find(p => p.name === order.name);
    if (product && product.ethPrice && order.quantity) {
        // This calculation assumes a hardcoded ETH price, which is incorrect.
        // It should use the fetched ethToUsd.
        // For now, keeping the original logic but highlighting it needs update.
      total += parseFloat(product.ethPrice) * parseInt(order.quantity) * (ethToUsd || 2000); // Using fetched rate or a fallback
    }
  });
  const taxWallet = total * 0.1; // Assuming a hardcoded tax rate

  document.getElementById("adminOrderValue").textContent = total.toFixed(2);
  document.getElementById("adminTaxWallet").textContent = taxWallet.toFixed(2);
  console.warn("Admin order totals and tax wallet are calculated based on localStorage and may not be accurate with real-time data. Consider updating this logic to use Firestore and the fetched ETH price rate.");
}

function updateTaxInfo() {
    // This function is called when admin logs in, triggers the localStorage-based total update
    updateAdminOrderTotals();
}


</script>
</body>
</html>
